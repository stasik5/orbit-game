<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ORBIT - A Game of Cosmic Balance</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0a1a;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: 300;
            text-shadow: 0 0 20px rgba(255, 200, 100, 0.5);
            letter-spacing: 2px;
        }
        
        #highScore {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            transition: opacity 0.5s;
        }
        
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 26, 0.95);
            pointer-events: auto;
        }
        
        #gameOverScreen {
            display: none;
        }
        
        h1 {
            font-size: 72px;
            font-weight: 100;
            color: #fff;
            letter-spacing: 20px;
            margin-bottom: 10px;
            text-shadow: 0 0 60px rgba(255, 200, 100, 0.3);
        }
        
        .subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 4px;
            margin-bottom: 60px;
        }
        
        .start-btn {
            background: linear-gradient(135deg, #ff6b6b, #ffa500);
            border: none;
            padding: 20px 60px;
            font-size: 18px;
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            letter-spacing: 3px;
            box-shadow: 0 10px 40px rgba(255, 107, 107, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 50px rgba(255, 107, 107, 0.4);
        }
        
        .start-btn:active {
            transform: translateY(0);
            transform: scale(0.95);
        }
        
        .final-score {
            font-size: 48px;
            color: #ffd700;
            margin: 20px 0;
            font-weight: 300;
        }
        
        .best-score {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 40px;
        }
        
        #powerupIndicator {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #debugText {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0f0;
            font-size: 20px;
            font-weight: bold;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="debugText"></div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <h1>ORBIT</h1>
        <p class="subtitle">A GAME OF COSMIC BALANCE</p>
        <button class="start-btn" onclick="startGame()">PLAY</button>
    </div>
    
    <div id="gameOverScreen">
        <h1>ORBIT</h1>
        <p class="subtitle">YOUR JOURNEY ENDS</p>
        <div class="final-score" id="finalScore">0</div>
        <p class="best-score" id="bestScore">BEST: 0</p>
        <button class="start-btn" onclick="startGame()">AGAIN</button>
    </div>
    
    <div id="ui">
        <div id="score">0</div>
        <div id="highScore">BEST: 0</div>
        <div id="powerupIndicator"></div>
        <div id="instructions">HOLD to expand â€¢ RELEASE to contract</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const size = Math.min(window.innerWidth, window.innerHeight);
            canvas.width = size;
            canvas.height = size;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Audio context for sound effects
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq, duration, type = 'sine', volume = 0.1) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.value = freq;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        function playCollectSound() {
            playSound(880, 0.1, 'sine', 0.08);
            setTimeout(() => playSound(1100, 0.15, 'sine', 0.06), 50);
        }
        
        function playDeathSound() {
            playSound(200, 0.3, 'sawtooth', 0.15);
            setTimeout(() => playSound(150, 0.4, 'sawtooth', 0.1), 100);
        }
        
        function playPowerupSound() {
            playSound(440, 0.1, 'sine', 0.1);
            setTimeout(() => playSound(660, 0.1, 'sine', 0.1), 80);
            setTimeout(() => playSound(880, 0.15, 'sine', 0.1), 160);
        }
        
        // Game state
        let gameState = 'menu'; // menu, playing, gameover
        let score = 0;
        let highScore = parseInt(localStorage.getItem('orbitHighScore')) || 0;
        let isHolding = false;
        let gameLoop;
        
        // Player (planet)
        const player = {
            orbitRadius: 100,
            targetRadius: 100,
            angle: 0,
            speed: 0.03,
            size: 12,
            color: '#4ecdc4',
            trail: [],
            shielded: false,
            magnetized: false
        };
        
        // Star (center)
        const star = {
            x: 0,
            y: 0,
            size: 30,
            pulse: 0
        };
        
        // Obstacles and collectibles
        let obstacles = [];
        let stars = [];
        let powerups = [];
        let particles = [];
        
        // Difficulty scaling
        let difficulty = 1;
        let gameTime = 0;
        
        // Orbital boundaries
        const minOrbit = 50;
        const maxOrbit = 200;
        
        function init() {
            score = 0;
            gameTime = 0;
            difficulty = 1;
            player.orbitRadius = 100;
            player.targetRadius = 100;
            player.angle = 0;
            player.shielded = false;
            player.magnetized = false;
            player.trail = [];
            obstacles = [];
            stars = [];
            powerups = [];
            particles = [];
            
            document.getElementById('score').textContent = '0';
            document.getElementById('highScore').textContent = `BEST: ${highScore}`;
        }
        
        function spawnObstacle() {
            const isInner = Math.random() < 0.5;
            const baseRadius = isInner ? minOrbit - 20 : maxOrbit + 20;
            const variance = Math.random() * 40 - 20;
            
            obstacles.push({
                angle: Math.random() * Math.PI * 2,
                orbitRadius: baseRadius + variance,
                size: 15 + Math.random() * 10,
                speed: (Math.random() * 0.01 + 0.005) * (isInner ? 1 : -1),
                isInner: isInner,
                rotation: Math.random() * Math.PI * 2
            });
        }
        
        function spawnStar() {
            const radius = minOrbit + Math.random() * (maxOrbit - minOrbit);
            stars.push({
                angle: Math.random() * Math.PI * 2,
                orbitRadius: radius,
                size: 8,
                collected: false,
                sparkle: 0
            });
        }
        
        function spawnPowerup() {
            const types = ['shield', 'slowtime', 'magnet'];
            const type = types[Math.floor(Math.random() * types.length)];
            const radius = minOrbit + Math.random() * (maxOrbit - minOrbit);
            
            powerups.push({
                angle: Math.random() * Math.PI * 2,
                orbitRadius: radius,
                size: 15,
                type: type,
                pulse: 0
            });
        }
        
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 4 + 2,
                    color: color,
                    life: 1
                });
            }
        }
        
        function updatePlayer() {
            // Smooth orbit transition
            const targetDiff = player.targetRadius - player.orbitRadius;
            player.orbitRadius += targetDiff * 0.1;
            
            // Update angle (orbit around star)
            player.angle += player.speed * (player.shielded ? 0.7 : 1);
            
            // Calculate position
            const x = star.x + Math.cos(player.angle) * player.orbitRadius;
            const y = star.y + Math.sin(player.angle) * player.orbitRadius;
            
            // Trail effect
            player.trail.unshift({ x, y, alpha: 1 });
            if (player.trail.length > 20) player.trail.pop();
            player.trail.forEach(t => t.alpha *= 0.9);
        }
        
        function updateObstacles() {
            obstacles.forEach(obs => {
                obs.angle += obs.speed;
                obs.rotation += 0.02;
            });
            
            // Remove off-screen or old obstacles
            obstacles = obstacles.filter(obs => {
                return Math.abs(obs.orbitRadius - player.orbitRadius) < 100;
            });
        }
        
        function updateStars() {
            stars.forEach(s => {
                s.sparkle += 0.1;
            });
            
            // Magnet effect
            if (player.magnetized) {
                stars.forEach(s => {
                    const playerX = star.x + Math.cos(player.angle) * player.orbitRadius;
                    const playerY = star.y + Math.sin(player.angle) * player.orbitRadius;
                    const starX = star.x + Math.cos(s.angle) * s.orbitRadius;
                    const starY = star.y + Math.sin(s.angle) * s.orbitRadius;
                    
                    const dx = playerX - starX;
                    const dy = playerY - starY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 80) {
                        s.orbitRadius += (player.orbitRadius - s.orbitRadius) * 0.05;
                    }
                });
            }
        }
        
        function updatePowerups() {
            powerups.forEach(p => {
                p.pulse += 0.1;
            });
        }
        
        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                p.size *= 0.95;
            });
            
            particles = particles.filter(p => p.life > 0);
        }
        
        function checkCollisions() {
            const playerX = star.x + Math.cos(player.angle) * player.orbitRadius;
            const playerY = star.y + Math.sin(player.angle) * player.orbitRadius;
            
            // Check obstacle collisions
            for (let obs of obstacles) {
                const obsX = star.x + Math.cos(obs.angle) * obs.orbitRadius;
                const obsY = star.y + Math.sin(obs.angle) * obs.orbitRadius;
                
                const dx = playerX - obsX;
                const dy = playerY - obsY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + obs.size) {
                    if (player.shielded) {
                        player.shielded = false;
                        createParticles(obsX, obsY, '#ff6b6b', 15);
                        playSound(300, 0.2, 'square', 0.1);
                        obstacles = obstacles.filter(o => o !== obs);
                        return;
                    } else {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Check star collection
            stars = stars.filter(s => {
                if (s.collected) return false;
                
                const starX = star.x + Math.cos(s.angle) * s.orbitRadius;
                const starY = star.y + Math.sin(s.angle) * s.orbitRadius;
                
                const dx = playerX - starX;
                const dy = playerY - starY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + s.size + (player.magnetized ? 30 : 0)) {
                    s.collected = true;
                    score += 10;
                    document.getElementById('score').textContent = score;
                    createParticles(starX, starY, '#ffd700', 8);
                    playCollectSound();
                    return false;
                }
                return true;
            });
            
            // Check powerup collection
            powerups = powerups.filter(p => {
                const powerX = star.x + Math.cos(p.angle) * p.orbitRadius;
                const powerY = star.y + Math.sin(p.angle) * p.orbitRadius;
                
                const dx = playerX - powerX;
                const dy = playerY - powerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + p.size) {
                    activatePowerup(p.type);
                    createParticles(powerX, powerY, '#00ff88', 15);
                    playPowerupSound();
                    return false;
                }
                return true;
            });
        }
        
        function activatePowerup(type) {
            const indicator = document.getElementById('powerupIndicator');
            
            switch(type) {
                case 'shield':
                    player.shielded = true;
                    indicator.textContent = 'ðŸ›¡ï¸ SHIELD ACTIVE';
                    indicator.style.opacity = 1;
                    setTimeout(() => {
                        if (!player.shielded) indicator.style.opacity = 0;
                    }, 5000);
                    break;
                    
                case 'slowtime':
                    player.speed *= 0.5;
                    indicator.textContent = 'â±ï¸ SLOW TIME';
                    indicator.style.opacity = 1;
                    setTimeout(() => {
                        player.speed *= 2;
                        indicator.style.opacity = 0;
                    }, 5000);
                    break;
                    
                case 'magnet':
                    player.magnetized = true;
                    indicator.textContent = 'ðŸ§² MAGNET';
                    indicator.style.opacity = 1;
                    setTimeout(() => {
                        player.magnetized = false;
                        indicator.style.opacity = 0;
                    }, 5000);
                    break;
            }
        }
        
        function draw() {
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update center position
            star.x = canvas.width / 2;
            star.y = canvas.height / 2;
            
            // Draw orbital boundaries (subtle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(star.x, star.y, minOrbit, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(star.x, star.y, maxOrbit, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw safe zone gradient
            const gradient = ctx.createRadialGradient(star.x, star.y, minOrbit, star.x, star.y, maxOrbit);
            gradient.addColorStop(0, 'rgba(78, 205, 196, 0.05)');
            gradient.addColorStop(1, 'rgba(255, 107, 107, 0.05)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(star.x, star.y, maxOrbit, 0, Math.PI * 2);
            ctx.arc(star.x, star.y, minOrbit, 0, Math.PI * 2, true);
            ctx.fill();
            
            // Draw star (center)
            star.pulse += 0.05;
            const starSize = star.size + Math.sin(star.pulse) * 3;
            
            const starGradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, starSize);
            starGradient.addColorStop(0, '#fff');
            starGradient.addColorStop(0.3, '#ffd700');
            starGradient.addColorStop(1, '#ff6b00');
            
            ctx.fillStyle = starGradient;
            ctx.beginPath();
            ctx.arc(star.x, star.y, starSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw star glow
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(star.x, star.y, starSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw collectible stars
            stars.forEach(s => {
                const x = star.x + Math.cos(s.angle) * s.orbitRadius;
                const y = star.y + Math.sin(s.angle) * s.orbitRadius;
                const sparkleSize = s.size + Math.sin(s.sparkle) * 2;
                
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
                
                // Star shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                    const r = i === 0 ? sparkleSize : sparkleSize;
                    const px = x + Math.cos(angle) * r;
                    const py = y + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw powerups
            powerups.forEach(p => {
                const x = star.x + Math.cos(p.angle) * p.orbitRadius;
                const y = star.y + Math.sin(p.angle) * p.orbitRadius;
                const pulseSize = p.size + Math.sin(p.pulse) * 3;
                
                let color, emoji;
                switch(p.type) {
                    case 'shield': color = '#00bfff'; emoji = 'ðŸ›¡ï¸'; break;
                    case 'slowtime': color = '#ff88ff'; emoji = 'â±ï¸'; break;
                    case 'magnet': color = '#88ff88'; emoji = 'ðŸ§²'; break;
                }
                
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, x, y);
            });
            
            // Draw obstacles
            obstacles.forEach(obs => {
                const x = star.x + Math.cos(obs.angle) * obs.orbitRadius;
                const y = star.y + Math.sin(obs.angle) * obs.orbitRadius;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(obs.rotation);
                
                // Asteroid shape
                ctx.fillStyle = '#8b4513';
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2;
                    const r = obs.size * (0.8 + Math.sin(i * 2.5) * 0.2);
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            });
            
            // Draw player trail
            player.trail.forEach((t, i) => {
                ctx.globalAlpha = t.alpha * 0.5;
                ctx.fillStyle = player.shielded ? '#00bfff' : player.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, player.size * (1 - i / player.trail.length), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw player
            const playerX = star.x + Math.cos(player.angle) * player.orbitRadius;
            const playerY = star.y + Math.sin(player.angle) * player.orbitRadius;
            
            const playerGradient = ctx.createRadialGradient(playerX, playerY, 0, playerX, playerY, player.size);
            playerGradient.addColorStop(0, '#fff');
            playerGradient.addColorStop(0.5, player.shielded ? '#00bfff' : player.color);
            playerGradient.addColorStop(1, player.shielded ? '#0066aa' : '#2a9d8f');
            
            ctx.fillStyle = playerGradient;
            ctx.shadowColor = player.shielded ? '#00bfff' : player.color;
            ctx.shadowBlur = player.shielded ? 20 : 15;
            ctx.beginPath();
            ctx.arc(playerX, playerY, player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Shield ring
            if (player.shielded) {
                ctx.strokeStyle = '#00bfff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(playerX, playerY, player.size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
        }
        
        function update() {
            if (gameState !== 'playing') return;
            
            gameTime++;
            difficulty = 1 + gameTime / 1000;
            
            // Control orbit based on input
            if (isHolding) {
                player.targetRadius = Math.min(maxOrbit, player.targetRadius + 2);
            } else {
                player.targetRadius = Math.max(minOrbit, player.targetRadius - 2);
            }
            
            updatePlayer();
            updateObstacles();
            updateStars();
            updatePowerups();
            updateParticles();
            checkCollisions();
            
            // Spawn entities
            if (gameTime % Math.max(30, 60 - difficulty * 5) === 0) {
                spawnObstacle();
            }
            if (gameTime % 40 === 0) {
                spawnStar();
            }
            if (gameTime % 300 === 0) {
                spawnPowerup();
            }
            
            // Score over time
            if (gameTime % 10 === 0) {
                score++;
                document.getElementById('score').textContent = score;
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            console.log("startGame called");
            
            // Show debug feedback
            const debugText = document.getElementById('debugText');
            debugText.textContent = 'CLICKED!';
            setTimeout(() => { debugText.textContent = 'GAME STARTED'; }, 500);
            setTimeout(() => { debugText.textContent = ''; }, 2000);
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('instructions').style.opacity = '0.4';
            
            init();
            gameState = 'playing';
            console.log("gameState:", gameState);
            
            // Initial spawns
            for (let i = 0; i < 3; i++) {
                spawnStar();
            }
            spawnObstacle();
            
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        
        function gameOver() {
            gameState = 'gameover';
            playDeathSound();
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('orbitHighScore', highScore);
            }
            
            // Create explosion particles
            const playerX = star.x + Math.cos(player.angle) * player.orbitRadius;
            const playerY = star.y + Math.sin(player.angle) * player.orbitRadius;
            createParticles(playerX, playerY, '#ff6b6b', 30);
            createParticles(playerX, playerY, player.color, 20);
            
            // Show game over screen
            setTimeout(() => {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('bestScore').textContent = `BEST: ${highScore}`;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }, 500);
        }
        
        // Input handlers
        function handleStart(e) {
            e.preventDefault();
            if (gameState === 'playing') {
                isHolding = true;
            }
        }
        
        function handleEnd(e) {
            e.preventDefault();
            isHolding = false;
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);
        
        // Touch events
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        // Keyboard events (spacebar)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'playing') {
                e.preventDefault();
                isHolding = true;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                isHolding = false;
            }
        });
        
        // Start game loop
        gameLoop();
        
        // Update high score display
        document.getElementById('highScore').textContent = `BEST: ${highScore}`;
    </script>
</body>
</html>
